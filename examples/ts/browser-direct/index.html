<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flowersec Direct Demo (Browser)</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; max-width: 920px; }
      textarea { width: 100%; height: 240px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
      pre { background: #0b1020; color: #e8e8e8; padding: 12px; border-radius: 8px; overflow: auto; }
      button { padding: 8px 12px; }
    </style>
  </head>
  <body>
    <h1>Flowersec Direct Demo (Browser)</h1>
    <p>This page uses the high-level client helper. For the manual stack, open <a href="./advanced.html">advanced.html</a>.</p>
    <p>Paste JSON from <code>examples/go/direct_demo</code>.</p>
    <textarea id="in" spellcheck="false"></textarea>
    <div style="margin: 12px 0">
      <button id="fetch" disabled>Fetch DirectConnectInfo</button>
      <button id="connect">Connect</button>
      <button id="close" disabled>Close</button>
      <span id="status" style="margin-left: 12px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;"></span>
    </div>
    <pre id="out"></pre>

    <script type="module">
      import { connectDirectBrowser } from "../../../flowersec-ts/dist/browser/index.js";
      import { createDemoSession } from "../../../flowersec-ts/dist/_examples/flowersec/demo/v1.facade.gen.js";
      import { createByteReader } from "../../../flowersec-ts/dist/streamio/index.js";

      // Browser notes:
      // - Browsers set the WebSocket Origin header automatically to window.location.origin.
      // - The direct demo server enforces an Origin allow-list; make sure you started it with an allowlist that includes
      //   this page's origin (e.g. http://127.0.0.1:5173).
      const $in = document.getElementById("in");
      const $out = document.getElementById("out");
      const $fetch = document.getElementById("fetch");
      const $connect = document.getElementById("connect");
      const $close = document.getElementById("close");
      const $status = document.getElementById("status");

      let sess = null;

      function logLine(s) {
        $out.textContent += s + "\n";
      }

      function setStatus(s) {
        $status.textContent = s;
      }

      async function detectDevServer() {
        try {
          const resp = await fetch("/__demo/status");
          if (!resp.ok) return;
          $fetch.disabled = false;
          setStatus("dev server detected");
        } catch {
          // ignore
        }
      }

      function waitHello(demo, timeoutMs) {
        return new Promise((resolve, reject) => {
          let unsub = () => {};
          const t = setTimeout(() => {
            unsub();
            reject(new Error("timeout waiting for notification"));
          }, timeoutMs);
          unsub = demo.onHello((payload) => {
            clearTimeout(t);
            unsub();
            resolve(payload);
          });
        });
      }

      $fetch.addEventListener("click", async () => {
        $out.textContent = "";
        setStatus("fetching info...");
        try {
          const resp = await fetch("/__demo/direct/info");
          const text = await resp.text();
          if (!resp.ok) throw new Error(`fetch failed (${resp.status}): ${text}`);
          const obj = JSON.parse(text);
          $in.value = JSON.stringify(obj, null, 2);
          setStatus("info loaded");
        } catch (e) {
          setStatus("fetch failed");
          logLine(String(e?.stack ?? e));
        }
      });

      $connect.addEventListener("click", async () => {
        $out.textContent = "";
        setStatus("connecting...");
        try {
          const info = JSON.parse($in.value);
          // High-level helper: it performs E2EE handshake + yamux + RPC.
          sess = createDemoSession(await connectDirectBrowser(info));
          $close.disabled = false;
          setStatus("connected");

          const notified = waitHello(sess.demo, 2000);
          const resp = await sess.demo.ping({});
          logLine("rpc response: " + JSON.stringify(resp));
          logLine("rpc notify: " + JSON.stringify(await notified));

          // Open a separate yamux stream ("echo") to show multiplexing over the same secure channel.
          // Note: openStream(kind) automatically writes the StreamHello(kind) preface.
          const echo = await sess.openStream("echo");
          const reader = createByteReader(echo);
          const msg = new TextEncoder().encode("hello over yamux stream: echo");
          await echo.write(msg);
          const got = await reader.readExactly(msg.length);
          logLine("echo response: " + JSON.stringify(new TextDecoder().decode(got)));
          await echo.close();
        } catch (e) {
          setStatus("error");
          logLine(String(e?.stack ?? e));
        }
      });

      $close.addEventListener("click", () => {
        sess?.close();
        sess = null;
        $close.disabled = true;
        setStatus("closed");
        logLine("closed");
      });

      detectDevServer();
    </script>
  </body>
</html>
