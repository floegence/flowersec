// Code generated by idlgen. DO NOT EDIT.

/** Feature bitset advertised during handshake. */
export enum E2EEFeatureBits {
  /** Supports rekey control records. */
  E2EEFeatureBits_rekey = 1,
}

/** Record type indicator for encrypted frames. */
export enum RecordFlags {
  /** Application data record. */
  RecordFlags_app = 0,
  /** Ping record. */
  RecordFlags_ping = 1,
  /** Rekey control record. */
  RecordFlags_rekey = 2,
}

/** Endpoint role for the E2EE handshake. */
export enum Role {
  /** Client endpoint. */
  Role_client = 1,
  /** Server endpoint. */
  Role_server = 2,
}

/** E2EE cipher suite identifier. */
export enum Suite {
  /** P-256 + HKDF-SHA256 + AES-256-GCM. */
  Suite_P256_HKDF_SHA256_AES_256_GCM = 2,
  /** X25519 + HKDF-SHA256 + AES-256-GCM. */
  Suite_X25519_HKDF_SHA256_AES_256_GCM = 1,
}

/** Client handshake ack payload. */
export interface E2EE_Ack {
  /** Handshake identifier being acknowledged. */
  handshake_id: string;
  /** Client Unix timestamp used for the auth tag. */
  timestamp_unix_s: number;
  /** Base64url-encoded auth tag. */
  auth_tag_b64u: string;
}

/** Client handshake init payload. */
export interface E2EE_Init {
  /** Channel identifier. */
  channel_id: string;
  /** Role of the sender (client). */
  role: Role;
  /** Protocol version. */
  version: number;
  /** Requested cipher suite. */
  suite: Suite;
  /** Base64url-encoded client ephemeral public key. */
  client_eph_pub_b64u: string;
  /** Base64url-encoded client nonce (32 bytes). */
  nonce_c_b64u: string;
  /** Client feature bits. */
  client_features: number;
}

/** Server handshake response payload. */
export interface E2EE_Resp {
  /** Handshake identifier for retries. */
  handshake_id: string;
  /** Base64url-encoded server ephemeral public key. */
  server_eph_pub_b64u: string;
  /** Base64url-encoded server nonce (32 bytes). */
  nonce_s_b64u: string;
  /** Server feature bits. */
  server_features: number;
}

function isRecord(v: unknown): v is Record<string, unknown> {
  return typeof v === "object" && v != null && !Array.isArray(v);
}

function assertString(name: string, v: unknown): string {
  if (typeof v !== "string") throw new Error(`bad ${name}`);
  return v;
}

function assertBoolean(name: string, v: unknown): boolean {
  if (typeof v !== "boolean") throw new Error(`bad ${name}`);
  return v;
}

function assertSafeInt(name: string, v: unknown): number {
  if (typeof v !== "number" || !Number.isSafeInteger(v)) throw new Error(`bad ${name}`);
  return v;
}

function assertU32(name: string, v: unknown): number {
  const n = assertSafeInt(name, v);
  if (n < 0 || n > 0xffffffff) throw new Error(`bad ${name}`);
  return n;
}

function assertU64(name: string, v: unknown): number {
  const n = assertSafeInt(name, v);
  if (n < 0) throw new Error(`bad ${name}`);
  return n;
}

function assertI32(name: string, v: unknown): number {
  const n = assertSafeInt(name, v);
  if (n < -2147483648 || n > 2147483647) throw new Error(`bad ${name}`);
  return n;
}

function assertI64(name: string, v: unknown): number {
  return assertSafeInt(name, v);
}

function assertStringMap(name: string, v: unknown): Record<string, string> {
  if (!isRecord(v)) throw new Error(`bad ${name}`);
  for (const [k, vv] of Object.entries(v)) {
    void k;
    if (typeof vv !== "string") throw new Error(`bad ${name}`);
  }
  return v as Record<string, string>;
}

const _E2EEFeatureBitsValues = new Set<number>([
  1,
]);

function assertE2EEFeatureBits(name: string, v: unknown): E2EEFeatureBits {
  const n = assertSafeInt(name, v);
  if (!_E2EEFeatureBitsValues.has(n)) throw new Error(`bad ${name}`);
  return n as E2EEFeatureBits;
}

const _RecordFlagsValues = new Set<number>([
  0,
  1,
  2,
]);

function assertRecordFlags(name: string, v: unknown): RecordFlags {
  const n = assertSafeInt(name, v);
  if (!_RecordFlagsValues.has(n)) throw new Error(`bad ${name}`);
  return n as RecordFlags;
}

const _RoleValues = new Set<number>([
  1,
  2,
]);

function assertRole(name: string, v: unknown): Role {
  const n = assertSafeInt(name, v);
  if (!_RoleValues.has(n)) throw new Error(`bad ${name}`);
  return n as Role;
}

const _SuiteValues = new Set<number>([
  2,
  1,
]);

function assertSuite(name: string, v: unknown): Suite {
  const n = assertSafeInt(name, v);
  if (!_SuiteValues.has(n)) throw new Error(`bad ${name}`);
  return n as Suite;
}

export function assertE2EE_Ack(v: unknown): E2EE_Ack {
  if (!isRecord(v)) throw new Error("bad E2EE_Ack");
  const o = v as Record<string, unknown>;
  if (o["handshake_id"] === undefined) throw new Error("bad E2EE_Ack.handshake_id");
  assertString("E2EE_Ack.handshake_id", o["handshake_id"]);
  if (o["timestamp_unix_s"] === undefined) throw new Error("bad E2EE_Ack.timestamp_unix_s");
  assertU64("E2EE_Ack.timestamp_unix_s", o["timestamp_unix_s"]);
  if (o["auth_tag_b64u"] === undefined) throw new Error("bad E2EE_Ack.auth_tag_b64u");
  assertString("E2EE_Ack.auth_tag_b64u", o["auth_tag_b64u"]);
  return o as unknown as E2EE_Ack;
}

export function assertE2EE_Init(v: unknown): E2EE_Init {
  if (!isRecord(v)) throw new Error("bad E2EE_Init");
  const o = v as Record<string, unknown>;
  if (o["channel_id"] === undefined) throw new Error("bad E2EE_Init.channel_id");
  assertString("E2EE_Init.channel_id", o["channel_id"]);
  if (o["role"] === undefined) throw new Error("bad E2EE_Init.role");
  assertRole("E2EE_Init.role", o["role"]);
  if (o["version"] === undefined) throw new Error("bad E2EE_Init.version");
  assertU32("E2EE_Init.version", o["version"]);
  if (o["suite"] === undefined) throw new Error("bad E2EE_Init.suite");
  assertSuite("E2EE_Init.suite", o["suite"]);
  if (o["client_eph_pub_b64u"] === undefined) throw new Error("bad E2EE_Init.client_eph_pub_b64u");
  assertString("E2EE_Init.client_eph_pub_b64u", o["client_eph_pub_b64u"]);
  if (o["nonce_c_b64u"] === undefined) throw new Error("bad E2EE_Init.nonce_c_b64u");
  assertString("E2EE_Init.nonce_c_b64u", o["nonce_c_b64u"]);
  if (o["client_features"] === undefined) throw new Error("bad E2EE_Init.client_features");
  assertU32("E2EE_Init.client_features", o["client_features"]);
  return o as unknown as E2EE_Init;
}

export function assertE2EE_Resp(v: unknown): E2EE_Resp {
  if (!isRecord(v)) throw new Error("bad E2EE_Resp");
  const o = v as Record<string, unknown>;
  if (o["handshake_id"] === undefined) throw new Error("bad E2EE_Resp.handshake_id");
  assertString("E2EE_Resp.handshake_id", o["handshake_id"]);
  if (o["server_eph_pub_b64u"] === undefined) throw new Error("bad E2EE_Resp.server_eph_pub_b64u");
  assertString("E2EE_Resp.server_eph_pub_b64u", o["server_eph_pub_b64u"]);
  if (o["nonce_s_b64u"] === undefined) throw new Error("bad E2EE_Resp.nonce_s_b64u");
  assertString("E2EE_Resp.nonce_s_b64u", o["nonce_s_b64u"]);
  if (o["server_features"] === undefined) throw new Error("bad E2EE_Resp.server_features");
  assertU32("E2EE_Resp.server_features", o["server_features"]);
  return o as unknown as E2EE_Resp;
}

