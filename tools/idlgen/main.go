package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type schema struct {
	Namespace string                 `json:"namespace"`
	Enums     map[string]enumDef     `json:"enums"`
	Messages  map[string]messageDef  `json:"messages"`
}

type enumDef struct {
	Type          string            `json:"type"`
	Comment       string            `json:"comment"`
	Values        map[string]int    `json:"values"`
	ValueComments map[string]string `json:"value_comments"`
}

type messageDef struct {
	Comment string     `json:"comment"`
	Fields  []fieldDef `json:"fields"`
}

type fieldDef struct {
	Name     string `json:"name"`
	Type     string `json:"type"`
	Comment  string `json:"comment"`
	Optional bool   `json:"optional"`
}

func main() {
	var inDir string
	var goOut string
	var tsOut string
	flag.StringVar(&inDir, "in", "", "input idl directory")
	flag.StringVar(&goOut, "go-out", "", "output directory for Go")
	flag.StringVar(&tsOut, "ts-out", "", "output directory for TypeScript")
	flag.Parse()

	if strings.TrimSpace(inDir) == "" || strings.TrimSpace(goOut) == "" || strings.TrimSpace(tsOut) == "" {
		fmt.Fprintln(os.Stderr, "missing -in/-go-out/-ts-out")
		os.Exit(2)
	}

	files, err := listFIDLFiles(inDir)
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if len(files) == 0 {
		fmt.Fprintln(os.Stderr, "no *.fidl.json files found")
		os.Exit(1)
	}

	schemas := make([]schema, 0, len(files))
	for _, p := range files {
		b, err := os.ReadFile(p)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		var s schema
		if err := json.Unmarshal(b, &s); err != nil {
			fmt.Fprintf(os.Stderr, "decode %s: %v\n", p, err)
			os.Exit(1)
		}
		if strings.TrimSpace(s.Namespace) == "" {
			fmt.Fprintf(os.Stderr, "missing namespace in %s\n", p)
			os.Exit(1)
		}
		schemas = append(schemas, s)
	}

	for _, s := range schemas {
		if err := genGo(goOut, s); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		if err := genTS(tsOut, s); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
	}
}

func listFIDLFiles(root string) ([]string, error) {
	var out []string
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if strings.HasSuffix(path, ".fidl.json") {
			out = append(out, path)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	sort.Strings(out)
	return out, nil
}

func genGo(outRoot string, s schema) error {
	domain, version, err := domainAndVersion(s.Namespace)
	if err != nil {
		return err
	}
	outDir := filepath.Join(outRoot, "flowersec", domain, version)
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}
	var buf bytes.Buffer
	buf.WriteString("// Code generated by idlgen. DO NOT EDIT.\n\n")
	buf.WriteString("package v1\n\n")
	buf.WriteString("import \"encoding/json\"\n\n")

	enumNames := sortedKeys(s.Enums)
	for _, name := range enumNames {
		ed := s.Enums[name]
		writeGoComment(&buf, ed.Comment, "")
		goType := "uint32"
		if strings.TrimSpace(ed.Type) == "u8" {
			goType = "uint8"
		} else if strings.TrimSpace(ed.Type) == "u16" {
			goType = "uint16"
		}
		fmt.Fprintf(&buf, "type %s %s\n\n", name, goType)
		buf.WriteString("const (\n")
		valueNames := sortedKeysInt(ed.Values)
		for _, vn := range valueNames {
			valueComment := ""
			if ed.ValueComments != nil {
				valueComment = ed.ValueComments[vn]
			}
			writeGoComment(&buf, valueComment, "\t")
			fmt.Fprintf(&buf, "\t%s_%s %s = %d\n", name, vn, name, ed.Values[vn])
		}
		buf.WriteString(")\n\n")
	}

	msgNames := sortedKeys(s.Messages)
	for _, name := range msgNames {
		md := s.Messages[name]
		writeGoComment(&buf, md.Comment, "")
		fmt.Fprintf(&buf, "type %s struct {\n", name)
		for _, f := range md.Fields {
			writeGoComment(&buf, f.Comment, "\t")
			goFieldName := exportName(f.Name)
			goType, err := goFieldType(f.Type)
			if err != nil {
				return fmt.Errorf("go type %s.%s: %w", name, f.Name, err)
			}
			if f.Optional {
				goType = "*" + goType
			}
			tag := fmt.Sprintf("`json:\"%s", f.Name)
			if f.Optional {
				tag += ",omitempty"
			}
			tag += "\"`"
			fmt.Fprintf(&buf, "\t%s %s %s\n", goFieldName, goType, tag)
		}
		buf.WriteString("}\n\n")
	}

	// Helper alias for JSON payloads.
	buf.WriteString("type JSON = json.RawMessage\n")

	outFile := filepath.Join(outDir, "types.gen.go")
	return os.WriteFile(outFile, buf.Bytes(), 0o644)
}

func goFieldType(t string) (string, error) {
	switch t {
	case "string":
		return "string", nil
	case "bool":
		return "bool", nil
	case "u8":
		return "uint8", nil
	case "u16":
		return "uint16", nil
	case "u32":
		return "uint32", nil
	case "u64":
		return "uint64", nil
	case "i32":
		return "int32", nil
	case "i64":
		return "int64", nil
	case "json":
		return "json.RawMessage", nil
	case "map<string,string>":
		return "map[string]string", nil
	default:
		if strings.HasPrefix(t, "[]") {
			elem, err := goFieldType(strings.TrimPrefix(t, "[]"))
			if err != nil {
				return "", err
			}
			return "[]" + elem, nil
		}
		// Treat as enum or message reference.
		return t, nil
	}
}

func genTS(outRoot string, s schema) error {
	domain, version, err := domainAndVersion(s.Namespace)
	if err != nil {
		return err
	}
	outDir := filepath.Join(outRoot, "flowersec", domain)
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}
	outFile := filepath.Join(outDir, version+".gen.ts")

	var buf bytes.Buffer
	buf.WriteString("// Code generated by idlgen. DO NOT EDIT.\n\n")

	enumNames := sortedKeys(s.Enums)
	for _, name := range enumNames {
		ed := s.Enums[name]
		writeTSComment(&buf, ed.Comment, "")
		buf.WriteString("export enum " + name + " {\n")
		valueNames := sortedKeysInt(ed.Values)
		for _, vn := range valueNames {
			valueComment := ""
			if ed.ValueComments != nil {
				valueComment = ed.ValueComments[vn]
			}
			writeTSComment(&buf, valueComment, "  ")
			fmt.Fprintf(&buf, "  %s_%s = %d,\n", name, vn, ed.Values[vn])
		}
		buf.WriteString("}\n\n")
	}

	msgNames := sortedKeys(s.Messages)
	for _, name := range msgNames {
		md := s.Messages[name]
		writeTSComment(&buf, md.Comment, "")
		buf.WriteString("export interface " + name + " {\n")
		for _, f := range md.Fields {
			writeTSComment(&buf, f.Comment, "  ")
			tsType, err := tsFieldType(f.Type)
			if err != nil {
				return fmt.Errorf("ts type %s.%s: %w", name, f.Name, err)
			}
			opt := ""
			if f.Optional {
				opt = "?"
			}
			fmt.Fprintf(&buf, "  %s%s: %s;\n", f.Name, opt, tsType)
		}
		buf.WriteString("}\n\n")
	}

	return os.WriteFile(outFile, buf.Bytes(), 0o644)
}

func tsFieldType(t string) (string, error) {
	switch t {
	case "string":
		return "string", nil
	case "bool":
		return "boolean", nil
	case "u8", "u16", "u32", "u64", "i32", "i64":
		return "number", nil
	case "json":
		return "unknown", nil
	case "map<string,string>":
		return "Record<string, string>", nil
	default:
		if strings.HasPrefix(t, "[]") {
			elem, err := tsFieldType(strings.TrimPrefix(t, "[]"))
			if err != nil {
				return "", err
			}
			return elem + "[]", nil
		}
		return t, nil
	}
}

func domainAndVersion(ns string) (domain string, version string, err error) {
	parts := strings.Split(ns, ".")
	if len(parts) < 3 {
		return "", "", fmt.Errorf("invalid namespace: %s", ns)
	}
	// Expected: flowersec.<domain>.v1 (or deeper, where <domain> is parts[1]).
	domain = parts[1]
	version = parts[len(parts)-1]
	return domain, version, nil
}

func exportName(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		if parts[i] == "" {
			continue
		}
		parts[i] = strings.ToUpper(parts[i][:1]) + parts[i][1:]
	}
	out := strings.Join(parts, "")
	if out == "Json" {
		return "JSON"
	}
	return out
}

func sortedKeys[T any](m map[string]T) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	sort.Strings(out)
	return out
}

func sortedKeysInt(m map[string]int) []string {
	out := make([]string, 0, len(m))
	for k := range m {
		out = append(out, k)
	}
	sort.Strings(out)
	return out
}

func splitCommentLines(comment string) []string {
	comment = strings.TrimSpace(comment)
	if comment == "" {
		return nil
	}
	lines := strings.Split(comment, "\n")
	out := make([]string, 0, len(lines))
	for _, line := range lines {
		out = append(out, strings.TrimRight(line, "\r"))
	}
	return out
}

func writeGoComment(buf *bytes.Buffer, comment string, indent string) {
	lines := splitCommentLines(comment)
	if len(lines) == 0 {
		return
	}
	for _, line := range lines {
		if line == "" {
			fmt.Fprintf(buf, "%s//\n", indent)
			continue
		}
		fmt.Fprintf(buf, "%s// %s\n", indent, line)
	}
}

func writeTSComment(buf *bytes.Buffer, comment string, indent string) {
	lines := splitCommentLines(comment)
	if len(lines) == 0 {
		return
	}
	if len(lines) == 1 {
		fmt.Fprintf(buf, "%s/** %s */\n", indent, lines[0])
		return
	}
	fmt.Fprintf(buf, "%s/**\n", indent)
	for _, line := range lines {
		if line == "" {
			fmt.Fprintf(buf, "%s *\n", indent)
			continue
		}
		fmt.Fprintf(buf, "%s * %s\n", indent, line)
	}
	fmt.Fprintf(buf, "%s */\n", indent)
}
