export type ProxyServiceWorkerScriptOptions = Readonly<{
  // If set, only requests whose pathname starts with this prefix are proxied.
  // Other requests fall through to the default network fetch.
  proxyPathPrefix?: string;
  // If true, the forwarded upstream path strips proxyPathPrefix (mapping the local mount prefix to upstream root).
  //
  // Example:
  // - proxyPathPrefix: "/apps/code/"
  // - request:        "/apps/code/static/app.js"
  // - forwarded:      "/static/app.js"
  stripProxyPathPrefix?: boolean;

  // If set, HTML responses are buffered and a small bootstrap module is injected into <head>.
  //
  // The injected module disables upstream SW registration and patches WebSocket by importing
  // "@floegence/flowersec-core/proxy" exports from proxyModuleUrl.
  injectHTML?: Readonly<{
    proxyModuleUrl: string;
    // The runtime is looked up from window.top[runtimeGlobal] (runtime mode with same-origin iframe).
    runtimeGlobal?: string;
  }>;
}>;

// createProxyServiceWorkerScript returns a Service Worker script that forwards fetches to a runtime
// in a controlled window via postMessage + MessageChannel.
//
// The runtime side is implemented by createProxyRuntime(...) in this package.
export function createProxyServiceWorkerScript(opts: ProxyServiceWorkerScriptOptions = {}): string {
  const proxyPathPrefix = opts.proxyPathPrefix ?? "";
  const stripProxyPathPrefix = opts.stripProxyPathPrefix ?? false;
  const injectHTML = opts.injectHTML ?? null;
  const proxyModuleUrl = injectHTML?.proxyModuleUrl?.trim() ?? "";
  const runtimeGlobal = injectHTML?.runtimeGlobal?.trim() ?? "__flowersecProxyRuntime";
  if (injectHTML != null && proxyModuleUrl === "") {
    throw new Error("injectHTML.proxyModuleUrl must be non-empty");
  }
  if (injectHTML != null && runtimeGlobal === "") {
    throw new Error("injectHTML.runtimeGlobal must be non-empty");
  }
  return `// Generated by @floegence/flowersec-core/proxy
const PROXY_PATH_PREFIX = ${JSON.stringify(proxyPathPrefix)};
const STRIP_PROXY_PATH_PREFIX = ${JSON.stringify(stripProxyPathPrefix)};
const INJECT_HTML = ${JSON.stringify(injectHTML != null)};
const PROXY_MODULE_URL = ${JSON.stringify(proxyModuleUrl)};
const RUNTIME_GLOBAL = ${JSON.stringify(runtimeGlobal)};
let runtimeClientId = null;

self.addEventListener("install", () => {
  // Take over as soon as possible.
  void self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(self.clients.claim());
});

self.addEventListener("message", (event) => {
  const data = event.data;
  if (!data || typeof data !== "object") return;
  if (data.type !== "flowersec-proxy:register-runtime") return;
  if (event.source && typeof event.source.id === "string") runtimeClientId = event.source.id;
});

async function getRuntimeClient() {
  if (runtimeClientId) {
    const c = await self.clients.get(runtimeClientId);
    if (c) return c;
    runtimeClientId = null;
  }
  const cs = await self.clients.matchAll({ type: "window", includeUncontrolled: true });
  if (cs.length > 0) {
    runtimeClientId = cs[0].id;
    return cs[0];
  }
  return null;
}

function headersToPairs(headers) {
  const out = [];
  headers.forEach((value, name) => out.push({ name, value }));
  return out;
}

function concatChunks(chunks) {
  let total = 0;
  for (const c of chunks) total += c.length;
  const out = new Uint8Array(total);
  let off = 0;
  for (const c of chunks) {
    out.set(c, off);
    off += c.length;
  }
  return out;
}

function injectBootstrap(html) {
  const snippet =
    '<script type="module">' +
    'import { installWebSocketPatch, disableUpstreamServiceWorkerRegister } from ' + JSON.stringify(PROXY_MODULE_URL) + ';' +
    'const rt = window.top && window.top[' + JSON.stringify(RUNTIME_GLOBAL) + '];' +
    'if (rt) { disableUpstreamServiceWorkerRegister(); installWebSocketPatch({ runtime: rt }); }' +
    '</script>';
  const lower = html.toLowerCase();
  const idx = lower.indexOf("<head");
  if (idx >= 0) {
    const end = html.indexOf(">", idx);
    if (end >= 0) return html.slice(0, end + 1) + snippet + html.slice(end + 1);
  }
  return snippet + html;
}

self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);
  if (PROXY_PATH_PREFIX && !url.pathname.startsWith(PROXY_PATH_PREFIX)) return;
  event.respondWith(handleFetch(event));
});

async function handleFetch(event) {
  const runtime = await getRuntimeClient();
  if (!runtime) return new Response("flowersec-proxy runtime not available", { status: 503 });

  const req = event.request;
  const url = new URL(req.url);
  const id = Math.random().toString(16).slice(2) + Date.now().toString(16);
  const body = (req.method === "GET" || req.method === "HEAD") ? undefined : await req.arrayBuffer();

  const ch = new MessageChannel();
  const port = ch.port1;
  const port2 = ch.port2;

  let metaResolve;
  let metaReject;
  const metaPromise = new Promise((resolve, reject) => { metaResolve = resolve; metaReject = reject; });

  const queued = [];
  const htmlChunks = [];
  let shouldInjectHTML = false;

  let doneResolve;
  let doneReject;
  const donePromise = new Promise((resolve, reject) => { doneResolve = resolve; doneReject = reject; });

  let controller = null;

  const stream = new ReadableStream({
    start(c) { controller = c; },
    cancel() {
      try { port.postMessage({ type: "flowersec-proxy:abort" }); } catch {}
      try { port.close(); } catch {}
    }
  });

  port.onmessage = (ev) => {
    const m = ev.data;
    if (!m || typeof m.type !== "string") return;
    if (m.type === "flowersec-proxy:response_meta") {
      if (INJECT_HTML) {
        const ct = String((m.headers || []).find((h) => (h.name || "").toLowerCase() === "content-type")?.value || "");
        shouldInjectHTML = ct.toLowerCase().includes("text/html");
      }
      metaResolve(m);
      if (controller && !shouldInjectHTML) for (const q of queued) controller.enqueue(q);
      if (shouldInjectHTML) for (const q of queued) htmlChunks.push(q);
      queued.length = 0;
      return;
    }
    if (m.type === "flowersec-proxy:response_chunk") {
      const b = new Uint8Array(m.data);
      if (shouldInjectHTML) {
        htmlChunks.push(b);
        return;
      }
      if (controller) controller.enqueue(b); else queued.push(b);
      return;
    }
    if (m.type === "flowersec-proxy:response_end") {
      if (shouldInjectHTML) {
        doneResolve(htmlChunks);
        return;
      }
      controller?.close();
      return;
    }
    if (m.type === "flowersec-proxy:response_error") {
      const err = new Error(m.message || "proxy error");
      metaReject(err);
      doneReject(err);
      controller?.error(err);
      try { port.close(); } catch {}
      return;
    }
  };

  let path = url.pathname + url.search;
  if (PROXY_PATH_PREFIX && STRIP_PROXY_PATH_PREFIX) {
    let rest = url.pathname.slice(PROXY_PATH_PREFIX.length);
    if (rest.startsWith("/")) rest = rest.slice(1);
    path = "/" + rest + url.search;
  }

  runtime.postMessage({
    type: "flowersec-proxy:fetch",
    req: { id, method: req.method, path, headers: headersToPairs(req.headers), body }
  }, [port2]);

  const meta = await metaPromise;
  const headers = new Headers();
  for (const h of (meta.headers || [])) headers.append(h.name, h.value);
  if (shouldInjectHTML) {
    const chunks = await donePromise;
    const raw = concatChunks(chunks);
    const html = new TextDecoder().decode(raw);
    const injected = injectBootstrap(html);
    return new Response(new TextEncoder().encode(injected), { status: meta.status || 502, headers });
  }

  return new Response(stream, { status: meta.status || 502, headers });
}
`;
}
